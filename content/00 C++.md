---
type: note
created: 30-10-2024 06:18
modified: 30-10-2024 06:18
aliases: 
category:
  - "[[31 Computer Science]]"
tags: 
---
  created: '30-10-2024 06:18'

***Общее для программ***
Выполнение программы идет сверху вниз, строго.
Если объявить using namespace std ранее элементов: 
```cpp
using namespace std;

#include "structures.h"
```

# 1	Низкоуровневый механизм языка 
## 1.1	Препроцессор



# 2	Основы 
## 2.1	Типы
Всегда нужно инициализировать переменные.
![[Pasted image 20250209193454.png]]

Функция определения типа:
typeid(), также эту функцию ещё относят к операторам почему-то[^2]
>«However, it is occasionally essential to know the exact type of an object. For example, we might like to know the name of the object’s class or its layout. The typeid operator serves this purpose by yielding an object representing the type of its operand.» ([Stroustrup, 2013, p. 658](zotero://select/library/items/YDHFPV3Z)) ([pdf](zotero://open-pdf/library/items/TJRBD2Y2?page=673&annotation=ZCB5K8X4))
- bool
Инициализируется с помощью 
### 2.1.1	Преобразование типов
Неявное преобразование типов
Стандартное преобразование int(str[0]), char(b)
## 2.2	Циклы
```cpp
 for (char& c : s)
 for(auto i = iterator) например.
```
## 2.3	Ввод/вывод
### 2.3.1	printf() - Обыкновенный ввод вывод C
 В коде C++ вы можете достигнуть эффекта растягивания одного вызова `printf` на несколько строк, используя символ обратного слэша (`\`) для соединения строк. Это позволяет записывать аргументы функции на несколько строк для улучшения читаемости кода, сохраняя целостность вызова функции.

Не работает с уникальными структурами C++.
 ```cpp
 printf("-Студент с максимальным баллом-"
            "Имя: %s\n"
            "Фамилия: %s\n",
            // "Максимальный балл: %d\n",
            students[max_student].First_name,
            students[max_student].Last_name
        );
	```
### 2.3.2	Поразрядные операции >> и << могут быть перегружены для ввода/вывода.
Это простая перегрузка.
Строки `istream&`.

В стандартный `cout` нельзя вывести  стандартный потоковый оператор вывода не поддерживает прямой вывод контейнеров, тип не поддерживаемый <<.
**Перегрузка оператора `<<` для `std::vector<int>`:**

Вы можете создать пользовательскую перегрузку оператора `<<` для типа `std::vector<int>`:
``` cpp
#include <vector>
#include <iostream>

// Функция для перегрузки оператора <<
std::ostream& operator<<(std::ostream& os, const std::vector<int>& vec) {
    for (const int& elem : vec) {
        os << elem << " ";
    }
    return os;
}
```
Также можно делать даже такие вещи: ![[Pasted image 20250204221119.png|400]]
## 2.4	Инициализация значений
Можно инициализировать структуры так:

```cpp
Student students[10] = {
        {"Aitov", "Aidar", {10,20,30}},
        {"Merenkov", "Fedor", },
        {"hfhhfh", "djfdkfj", }
    };
```
Эта инициализация называется **списковая инициализация** (или _uniform initialization_). В C++11 и более поздних стандартах она позволяет инициализировать объекты и массивы с помощью фигурных скобок `{}`.

Списковая инициализация предоставляет несколько преимуществ:

1. **Безопасность типов**: Запрещает неявные преобразования типов, что помогает избежать ошибок времени выполнения.
2. **Инициализация по умолчанию**: Если какой-то элемент в списке инициализации не указан, он инициализируется значением по умолчанию для этого типа.
3. **Удобство**: Позволяет инициализировать сложные структуры данных в читаемой и компактной форме.

Пример вашей инициализации входит именно в этот вид инициализации, где элементы массива структур инициализируются с помощью списков внутри фигурных скобок.

- vector() 
- vector = {} 
- vector[] 
-  vector(0,0)
## 2.5	Функции
Перегрузки функции, например как функции **max()**.
Перегрузки больше языковая особенность. Можно перегружать также операторы(как в вводе выводе << >>), а также конструкторы.
![[Pasted image 20250202144452.png]]
В данном случае это  перегрузка (overloading), а не переопределение (overriding). В C++ разрешено создавать несколько функций с одинаковым именем, если у них разные сигнатуры (например, различаются типы или количество параметров). 

Переопределение же относится к методам классов, унаследованных от базового класса, и требует наличия виртуальных функций. Поэтому иметь несколько прототипов одной и той же функции в C++ допустимо и часто используется для удобства.
## 2.6	Как работает индексация в c++:
  
Индексация в динамических массивах в C++ работает аналогично индексации в статических массивах, но с некоторыми особенностями, связанными с управлением памятью.
## 2.7	Массивы
### 2.7.1	Срезы в C++
В C++ нет встроенного механизма срезов, как в Python.
Для извлечения поддиапазонов приходится полагаться на привязку к шаблонам, итераторам, std::span

### 2.7.2	Двумерные динамические массивы
Два основных подхода выделения памяти для них:
4. **Массив массивов (массив указателей)**: 
   - Выделяется массив указателей, затем для каждой строки выделяется массив целых чисел.
```cpp
int** matrix = new int*[rows];
for (int i = 0; i < rows; ++i) {
	matrix[i] = new int[cols];
} 
```
   - Доступ к элементам аналогичен обычной индексации двумерного массива:
```cpp
matrix[i][j] = value;
int x = matrix[i][j];
```
5. **Одномерный массив с вычислением индекса**:
   - Используется одномерный массив, где индекс расчитывается вручную.
   ```cpp
   int* matrix = new int[rows * cols];
   ```
   - Индекс вычисляется как `matrix[i * cols + j]`, что позволяет получить доступ к элементу \((i, j)\).
- **Массив массивов**:
  ```cpp
  for (int i = 0; i < rows; ++i) {
      delete[] matrix[i];
  }
  delete[] matrix;
  ```
- **Одномерный массив**:
  ```cpp
  delete[] matrix;
  ```
#### 2.7.2.1	Освобождение памяти для двумерных массивов

### 2.7.3	Особенности
- **Память выделяется в куче**, так что после ее использования необходимо выполнить `delete[]`, чтобы избежать утечек памяти.
- **Граничные значения**: Неверное использование индексов может привести к сегментационным ошибкам или неправильным данным, поэтому важно следить за управлением границами массива. 



#### 2.7.3.1	Передача массива в функцию

• **Передача массива как «int arr[]» или «int arr[N]» в сигнатуре функции**  
  – В действительности в функцию поступает указатель (int*).  Это явное наследие C.
  – Длина массива не известна, её необходимо передавать отдельно или вычислять иным способом.  

• **Передача массива через “int* ptr”**  
  – Явная форма обращения, сразу говорит о том, что функция работает с указателем.
  – Аналогично предыдущему пункту, без дополнительной информации о размере массива функция не знает, сколько элементов доступно.  

Если требуется, чтобы функция видела весь массив и знала его точный размер на этапе компиляции, в современных реалиях C++ часто применяют передачу массива по ссылке с указанием размера в шаблоне, например:
```cpp
template <size_t N>  
void func(int (&arr)[N]) {  
    // Здесь N – размер массива, и он известен во время компиляции.  
}
```

##### 2.7.3.1.1	Тип данных std:array

## 2.8	Символьные структуры данных и массивы
### 2.8.1	Строки
#### 2.8.1.1	Методы возвращение длины строки
std::string (и других специализаций std::basic_string) методы length() и size() возвращают одно и то же значение и не отличаются по функциональности. Оба они возвращают текущее число символов в строке.

Исторически:  
• size() обычно ассоциируется с общими контейнерами STL и является стандартным методом для определения размера контейнера;  
• length() появился для удобства, чтобы слово “length” лучше отражало количество символов в строке как в классическом представлении длины строки.  

Однако на уровне реализации они эквивалентны и возвращают одинаковое значение типа size_t. Это подтверждается в документации:  
https://en.cppreference.com/w/cpp/string/basic_string/size)
https://en.cppreference.com/w/cpp/string/basic_string/length

#### 2.8.1.2	Что делает strtok.
Возвращает указатель на следующий токен, найденный в _`str`_. Возвращает, `NULL`когда больше маркеров не найдено. Каждый вызов изменяет _`str`_ путем замены символа NULL для первого разделителя, который возникает после возвращаемого маркера. 

Из личного опыта(ОКАЗАЛОСЬ НЕВЕРНО) - Он заменяет символ разделителя(в моем случае пробел) на знак окончания строки, тем самым выделяя токен.
![[Pasted image 20241220135801.png]]
Есть два вида функции ввода getline.
- cin.getline - для символьных массивов. 
- getline - только для строк.
	`getline(stdin(cin), string)`
	
#### 2.8.1.3	Конкатенация строки и других типов данных - ?
```cpp
return string(s[i-1])+s[i];
```
## 2.9	Генерирование случайных значений
В C++ очень неудобный генератор случайных значений.

Примеры использования:
```cpp
for (int i = 0; i < num_people; ++i) {
        people[i].first_name = first_names[rand() % (sizeof(first_names) / sizeof(first_names[0]))];
        people[i].last_name = last_names[rand() % (sizeof(last_names) / sizeof(last_names[0]))];
    }
```

`rand() % 100
```cpp
int x = rand() % (end - start + 1) + start;
````
Как вы можете видеть, мы сначала “обрезаем” сгенерированное число до нужного нам размера с помощью остатка от деления, а потом сдвигаем его так, чтобы 0 стал равен началу диапазона.


Для более простого и гибкого управления диапазоном случайных чисел можно использовать стандартную библиотеку `<random>`, которая появилась в C++11. Эта библиотека предоставляет разнообразные генераторы случайных чисел и распределения. Вот несколько примеров использования:
https://stackoverflow.com/questions/19665818/generate-random-numbers-using-c11-random-library

Для генерации случ. чисел с гаранитей точного выпадения числа классическая задача называемая генерирование с заданным законом распределения.
## 2.10	Структуры,  и классы
Объявление элементов в структурах
>После структуры нужно ставить ;

Можно задавать методы у структур.
Смысл задавать реализацию структуры внутри другой структуры
![[Pasted image 20250220100502.png]]
Visual Studio code почему то называет структуру классом: 
`class "Student" has no member "Last_name"C/C++(135)`




Если не знать размера массива структур, то я знаю что можно вычислить с помощью оператора sizeof().
// for(int i = 0; i < sizeof(students)/sizeof(Student); i++)
наследование

### 2.10.1	Доступ к элементам структур и размеры структур
Размеры вынесу в отдельный раздел `Низкоуровневый механизм`

### 2.10.2	Для инициализации массива структур можно  
Использовать списковую инициализацию C++ 11 в формате:
Почему элементы получаются по структуре `->` и точка для массива.

## 2.11	Заголовочные файлы(headers)
Чтобы внести заголовчные файлы нужно задать его в кавычки: `"structures.h"` - почему?
Для предотвращения многократного включения файла используется `#ifndef` ... `#define` ... `#endif` (защитные макросы).
## 2.12	STL и структуры данных
Реализация [[Контейнеры(Коллекции)|Контейнеров]] в C++.
Почему контейнеры разделяют на такие категории, как `Ассоциативные, Последовательные и адаптеры`:
>Каждый тип контейнера имеет свои особенности, что делает его наиболее подходящим для определенных задач. Например, для частых операций добавления и удаления элементов лучше использовать `deque`, тогда как для хранения уникальных элементов подойдет `set`

Категории контейнеров отражают основные различия и их предназначение, что помогает разработчикам выбирать наиболее подходящий инструмент для конкретной задачи. Эти категории объединяют контейнеры с общими свойствами и способом использования. Рассмотрим причины и смыслы такого деления.

#### 2.12.1.1	Причины классификации контейнеров
1. **Метод доступа к элементам**:
   - **Последовательные контейнеры (Sequential containers)**:
     - **Упорядоченные** и **Прямой доступ**: Эти контейнеры хранят элементы в порядке их вставки и позволяют доступ к элементам по индексу. Примеры: `std::vector`, `std::deque`, `std::list`, `std::array`, `std::forward_list`. Главный акцент здесь на **упорядоченность элементов** и **простоту применения** для последовательного перебора или прямого доступа к элементам.

   - **Непоследовательные контейнеры (Unordered containers)**:
     - **Неупорядоченные** и **Хэширование**: Такие контейнеры помогают быстро находить, добавлять и удалять элементы без поддержки порядка вставки. Они основаны на хеш-таблицах. Примеры: `std::unordered_set`, `std::unordered_map`, `std::unordered_multiset`, `std::unordered_multimap`. Эти контейнеры предоставляют **эффективное время доступа** к элементам с постоянной амортизированной сложностью (для большинства операций).

2. **Тип данных и способ хранения**:

   - **Ассоциативные контейнеры (Associative containers)**:
     - **Упорядоченные**: Они хранят элементы в отсортированном порядке и используют деревья поиска. Примеры: `std::set`, `std::map`, `std::multiset`, `std::multimap`. Они обеспечивают **эффективный логарифмический доступ** к элементам по ключу, что делает их полезными для упорядоченного хранения и быстрого поиска.

3. **Примеры узкоспециализированного использования**:
   - **Контейнеры-адаптеры (Container adaptors)**:
     - **Ограниченный интерфейс**: Контейнеры-адаптеры, такие как `std::stack`, `std::queue`, и `std::priority_queue`, предоставляют специфический, ограниченный интерфейс для работы с данными. Они адаптируют другие контейнеры для реализации конкретных абстракций данных. Контейнеры-адаптеры создают более специализированные структуры данных, ограничивая доступ и манипуляции для соблюдения определенных свойств (например, стек — принцип LIFO, очередь — принцип FIFO).

4. **Способы оптимизации и алгоритмическая сложность**:
   - **Баланс между скоростью доступа и гибкостью**: *Каждая* категория оптимизирована для определенного набора операций. Непосредственное понимание алгоритмической сложности, порядка элементов и методов доступа помогает в выборе наилучшего контейнера для приложений, что важно для **эффективности программ**.
***Вывод***
Классификация контейнеров в таких категориях, как последовательные, ассоциативные и адаптеры, основана на их внутренней структуре, методах доступа и 
	Эти категории формируют основополагающую часть теории структур данных и алгоритмов, лежащую в основе большинства современных программных библиотек. 
#### 2.12.1.2	Основные критерии (признаки) для классификации контейнеров:
1. **Метод доступа**:
   - **Прямой доступ (Random access)**: Позволяет доступ к элементам по индексу, как в массиве. Примеры: `std::vector`, `std::deque`, `std::array`.
   - **Последовательный доступ (Sequential access)**: Элементы можно обходить только последовательно, один за другим. Примеры: `std::list`, `std::forward_list`.

2. **Порядок хранения**:
   - **Упорядоченные (Ordered)**: Элементы хранятся в определенном порядке, который обычно задается пользователем или самой структурой данных. Примеры: `std::set`, `std::map`.
   - **Неупорядоченные (Unordered)**: Порядок элементов не определен и может изменяться. Примеры: `std::unordered_set`, `std::unordered_map`.

3. **Тип адаптера**:
   - Контейнеры, которые адаптируют другой контейнер для предоставления ограниченного интерфейса (например, стек, очередь). Примеры: `std::stack`, `std::queue`, `std::priority_queue`.
Почему именно такая классификация?(последовательные и ассоциативные и адаптеры)

### 2.12.2	[[Итераторы]]
В конце каждого STL контейнера есть итераторы.
**Главный смысл итераторов как я понял это сокращение количества явных циклов.** 
**И удобство в выделении диапазона в массиве, в вызове функций, так как например мы можем передать лишь итераторы в функции max_element, для нахождения элемента$^{вопросик}$**


#### 2.12.2.1	Моменты ошибок с итераторами
Здесь когда итератор i доходит до digits.rend() он разыменовывает его, а потом только проверяет вышел ли я за границы.
```cpp
while(*i == 9 && i != digits.rend())
```
#### 2.12.2.2	Что такое итератор(тип данных?)
Не стоит буквально приравнивать итератор к указателю, хотя в C++ они во многом схожи по синтаксису и поведению:

• Указатель — это низкоуровневый механизм, содержащий адрес в памяти.  
• Итератор — это более абстрактная концепция, которая «указывает» на элемент контейнера, но реализация может отличаться в зависимости от типа контейнера.

**Итератор** содержит позиции элементов массива, не как указатель, который содержит адрес элемента. 
**Вывод адресов элементов массива:**
```cpp
 vector<int> arr(n);
    for(auto i = arr.rbegin(); i != arr.rend(); i++) {
        printf("%d\n", &(*i));
    }
```

**Например:**  
• В std::vector итератор обычно реализован как обычный указатель (поскольку элементы хранятся в непрерывном участке памяти). Его работа во многом совпадает с тем, как вы бы использовали «сырые» указатели.  
• В std::list, std::map и других контейнерах итераторы могут быть объектами, работающими под капотом со структурами типа двусвязного списка или сложных деревьев. Они ведут себя как указатели лишь на логическом уровне (например, позволяют проходить элементы, разыменовать итератор, использовать инкремент/декремент), но реального указателя внутри может не быть.

В итоге:  
–– Итератор можно мыслить как «умный» указатель на элемент контейнера, но технически это не всегда простой сырой адрес в памяти. Главное — он даёт единообразный интерфейс для обхода различных контейнеров.

Что возвращает begin - Особый тип данных std::vector\<int>::iterator
#### 2.12.2.3	Итераторы разных типов данных
Со стандарта C++11 стало возможно получать итреаторы для массивов с помощью функции begin и end.
Итераторы vector:

|                                                                                                                       |                                                                                                                                                                                                              |
| --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [begincbegin](https://ru.cppreference.com/w/cpp/container/deque/begin "cpp/container/deque/begin")<br><br>(C++11)     | возвращает итератор на начало  <br>(public функция-элемент)[[править]](https://ru.cppreference.com/mwiki/index.php?title=%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD:cpp/container/dsc_begin&action=edit)           |
| [endcend](https://ru.cppreference.com/w/cpp/container/deque/end "cpp/container/deque/end")<br><br>(C++11)             | возвращает итератор на конец  <br>(public функция-элемент)[[править]](https://ru.cppreference.com/mwiki/index.php?title=%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD:cpp/container/dsc_end&action=edit)              |
| [rbegincrbegin](https://ru.cppreference.com/w/cpp/container/deque/rbegin "cpp/container/deque/rbegin")<br><br>(C++11) | возвращает обратный итератор на начало  <br>(public функция-элемент)[[править]](https://ru.cppreference.com/mwiki/index.php?title=%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD:cpp/container/dsc_rbegin&action=edit) |
| [rendcrend](https://ru.cppreference.com/w/cpp/container/deque/rend "cpp/container/deque/rend")<br><br>(C++11)         | возвращает обратный итератор на конец  <br>(public функция-элемент)                                                                                                                                          |

**Отличие rbegin от end:**
Возвращает итератор, который идет от конца к началу(по сути список reversed адресов) и rbegin *указывает* на последний элемент, а end указывает на адрес *после* последнего элемента, как заглушка.

#### 2.12.2.4	Как использовать итераторы:
Можно инициализировать [[std vector| vector]] с помощью итераторов других структур данных например deque.

Перебор элементов с конца в начало:
 ```cpp
 int n = 10;
    vector<int> arr(n);
    for(auto i = arr.rbegin(); i != arr.rend(); i++) {
        cin >> *i;
    }
```
#### 1.3.1.1	Преобразование итераторов
9. **Convert to a normal iterator and then get the pointer**: Since `base()` returns a normal iterator that points to the element after the one pointed to by the reverse iterator, you could do this:
```cpp
std::vector<int>::reverse_iterator rpos = v.rbegin();
std::vector<int>::iterator it = rpos.base();
// Decrement it to point to the same element as rpos
--it;
int* ptr = &(*it);
```

### 1.3.2	Последовательные контейнеры(коллекции)
#### 1.3.2.1	std::array\<T>
	Этот STL шаблон позволяет передавать размер массива.
#### 1.3.2.2	std::deque\<T>
Двусторонняя очередь.
	Deque сочетает идею двусвязного списка и динамического массива, поэтому он эффективен для операций в начале и конце, но доступ к элементу по индексу может быть медленнее в сравнении с обычным массивом [1](https://metanit.com/cpp/tutorial/7.8.php)[2](http://cppstudio.com/post/8469/). Используйте deque, когда важны быстрая вставка/удаление в начале/конце и при этом необходим доступ к элементам по индексу.
https://ru.cppreference.com/w/cpp/container/deque

#### 1.3.2.3	std::vector\<T\>
https://en.cppreference.com/w/cpp/container/vector/insert
[[std vector]]
##### 1.3.2.3.1	**Методы:**
###### 1.3.2.3.1.1	insert
Один из наиболее часто используемых методов - это функция `insert`. Важно отметить, что вставка элемента в начало вектора может быть не самой эффективной операцией для `std::vector`, все последующие элементы надо сдвигать.
- Чтобы вставить элемент, нужно использовать **итератор** на позицию *перед элементом*. Пример: `vec.insert(vec.begin()+2, 3)`
###### 1.3.2.3.1.2	insert_range (==C++ 23==)

###### 1.3.2.3.1.3	emplace (==C++ 11==)
Функция `emplace` также может быть использована для вставки элемента в начало вектора, и она позволяет разместить элемент "на месте", что может быть более эффективно для объектов с большими конструкторами.
### 1.3.3	Ассоциативные контейнеры[^1]
Ассоциативные контейнеры реализуют упорядоченные структуры данных с возможностью быстрого поиска (со сложностью O(log n)).

#### 1.3.3.1	std::map\<T>
>«A map is most likely implemented as a (balanced) tree of nodes pointing to (key,value) pairs:» ([Stroustrup, 2013, p. 889](zotero://select/library/items/YDHFPV3Z)) ([pdf](zotero://open-pdf/library/items/TJRBD2Y2?page=904&annotation=LHCQLVBF))

![[Pasted image 20250126214658.png]]
```cpp
std::map<char, int> freq;
```
### 1.3.4	Неупорядоченные ассоциативные контейнеры
Неупорядоченные ассоциативные контейнеры реализуют неупорядоченные (хешированные) структуры данных с возможностью быстрого поиска (со средней сложностью O(1), в худшем случае O(n)).

#### 1.3.4.1	std::unordered_map\<T>
>«An unordered_map is most likely implemented as a hash table:» ([Stroustrup, 2013, p. 889](zotero://select/library/items/YDHFPV3Z)) ([pdf](zotero://open-pdf/library/items/TJRBD2Y2?page=904&annotation=AXTTMCF4))
![[Pasted image 20250126214650.png]]

### 1.3.5	Адаптеры контейнеров
Адаптеры контейнеров предоставляют различные интерфейсы для последовательных контейнеров.

### 1.3.6	Представления
Представления предоставляют гибкие средства для взаимодействия с одномерными или многомерными представлениями над массивом элементов, не являющимся владельцем.

## 1.4	Исключения и как ловить их

## 1.5	


# 2	Встроенные библиотеки(заголовки)
### 2.1.1	<algorithm\>
Почему то много функций с пространством имен ranges:: 

*Функции:*
#### 2.1.1.1	Sorting operations
- `sort(begin*, end*, cmpfunc)`
Complexity
Given NN as last - first:
1,2) O(N⋅log⁡(N)) comparisons using operator\<(until C++20)[std::less](http://en.cppreference.com/w/cpp/utility/functional/less){}(since C++20).
3,4) O(N⋅log(N))applications of the comparator comp.

Для сортировки структур необходимо определить оператор сравнения:
- `is_sorted()`

#### 2.1.1.2	Minimum/maximum operations
- `max()`
с какого то там стандарта можно находить максимум из initializer_list. Но это все равно список значений а не массив.

- `max_element()`
Позволяет находить максимальное значение в range(в том числе массиве).
#### 2.1.1.3	Swap operations
- `swap()`
https://en.cppreference.com/w/cpp/algorithm/swap
- 
#### 2.1.1.4	Order-changing operations
- `reverse()`
https://en.cppreference.com/w/cpp/algorithm/reverse
|                                                                                                                             |                                                                         |
| --------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| [ranges::shuffle](https://en.cppreference.com/w/cpp/algorithm/ranges/shuffle "cpp/algorithm/ranges/shuffle")<br><br>(C++20) | randomly re-orders elements in a range  <br>(algorithm function object) |
#### 2.1.1.5	Modifying sequence operations
- `remove()`
Removes all elements satisfying specific criteria from the range `[`first`,` last`)` and returns a past-the-end iterator for the new end of the range.

https://www.getmerlin.in/chat/share/7516871a-7330-4bf7-98f6-0a75f0f4778e
https://learn.microsoft.com/ru-ru/cpp/c-runtime-library/reference/strtok-strtok-l-wcstok-wcstok-l-mbstok-mbstok-l?view=msvc-170
## 2.2	\<iterator>
std::greater
## 2.3	\<bits/stdc++.h>
Вроде библиотека для олимпиадного программирования.

## \<ctime>
![[Pasted image 20250306100727.png]]
https://ru.stackoverflow.com/questions/264003/%D0%9A%D0%B0%D0%BA-%D0%B2%D1%8B%D0%B2%D0%B5%D1%81%D1%82%D0%B8-%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B0%D1%82%D1%83-%D0%B8-%D0%B2%D1%80%D0%B5%D0%BC%D1%8F
# 3	Детали различных стандартов с++
«The standard doesn’t prescribe a particular representation for a standard container» ([Stroustrup, 2013, p. 888](zotero://select/library/items/YDHFPV3Z)) ([pdf](zotero://open-pdf/library/items/TJRBD2Y2?page=903&annotation=6EM5JCMG)). А определяет интерфейсы и требования к поведению контейнеров. Это позволяет разработчикам библиотек оптимизировать реализации контейнеров для различных платформ и целей. 

Реализация контейнеров стандартной библиотеки C++ ложится на плечи разработчиков компиляторов и сопровождающих их стандартных библиотек. Различные компиляторы могут включать свои собственные реализации стандартных контейнеров, обеспечивая спецификации, данные в стандартном языке C++.

# 4	Интересные подходы с использованием C++(уникальность)
## 4.1	Сравнение с помощью XOR-ов
Интересный способ на мой взгляд проверки отсутствия только одного элемента.

# 5	Другие библиотеки
## 5.1	Boost
Она позволяет более удобно выводить контейнеры.


# 6	Особенности C++




links::

[^1]: Как их реализовали? Как создаются новые узлы и т.д.

[^2]: Вопрос прям
	
