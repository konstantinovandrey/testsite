---
type: note
created: 18-01-2025 17:40
modified: 18-01-2025 17:40
aliases: 
category: 
tags: 
---
created: '18-01-2025 17:40'

# 1	Ресурсы по python:
1) https://www.reddit.com/r/learnpython/comments/12bnuk0/whats_the_best_book_about_learning_python/ - Интересный пост о литературе про python
2) https://365datascience.com/tutorials/python-tutorials/best-python-books/
3) 

Python и базы данных
![[Pasted image 20250118174119.png]]
https://habr.com/ru/articles/321510/

ORM
В больших проектах на Python чаще всего используются SQLAlchemy и Django ORM. Эти две библиотеки считаются самыми популярными и надёжными благодаря своей мощи и гибкости.
![[Pasted image 20250118174139.png]]
https://habr.com/ru/articles/322086/



# 2	PEP's(Стандарты PEP)
## 2.1	PEP 8
Этот стандарт направлен на оформление кода, я задумался об оформление с момента когда Бесков сказал про оформление структур в C++ и также я 

# 3	Низкоуровневый механизм языка
## 3.1	Объектная модель в Python
Классы и генерируемые экземпляры являются двумя отдельными типами объектов.
1. Сколько памяти занимают экземпляры, при создании пустыми?

Вопросы которые помогут понять низкоуровневый механизм языка, но важно ли понимать низкоуровневый механизм языка?
1. Как устроено вложение на любую глубину у последовательностей? Как же Python так умело поддерживает переключение между контейнерами и последовательностями?
2. Почему есть изменяемые и неизменяемые типы данных?

# 4	Основы языка
**Особенности синтаксиса Python включают в себя отступы и отсутствие обязательных скобок**. Также разность регистров символов, например Scene и scene.
- Язык интерпретируемый, выполняется сразу, но нужен интерпретатор[^1]
## 4.1	Ввод вывод(i/o)
Как же хорошо устроен оператор print в python, я могу подставить под переменные ЛЮБЫЕ объекты:
```python
print(f'Калькулятор {self.myAddress}: {a} {op} {b} = {result}')
```

## 4.2	Циклы и Итераторы
### 4.2.1	Срезы
Срез `[1:]` когда у нас 1 элемент, то есть `values[0]` даёт весь массив, если дальше его дополнять.
## 4.3	Функции
Такого механизма перегрузки, какой есть в C++ (компиляторная проверка разных сигнатур), в языке Python нет.
В Python можно объявлять функции внутри других функций, и это связано с тем, что Python поддерживает **вложенные функции (nested functions)**. Это мощная особенность языка, которая позволяет создавать более гибкие и модульные конструкции. Вот несколько причин, почему это возможно и полезно:

«В части IV было указано, что def на самом деле представляет собой присваивание.» ([Лутц, p. 36](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=37&annotation=64MQ8ATQ))



Есть такой механизм:  **Замыкания (Closures)**
### 4.3.1	Магические методы
\_\_init__
## 4.4	Области видимости[^4]
**Область видимости** - это место, где переменные определяются и ищутся.[^3]



«С другой стороны, области видимости способны предоставить способ сохранения информации о состоянии между вызовами функции, а в определенных ролях выступают в качестве альтернативы классам.» ([Лутц, p. 504](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=505&annotation=8MCTUXS7))
«Почти все, что связано с именами, включая классификацию областей видимости, в Python происходит во время присваивания.» ([Лутц, p. 504](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=505&annotation=EJPVKFMM)). В других языках место присваивания может не влиять, например `static global`.


### 4.4.1	Лексическая область видимости[^11]
- <mark style="background: #ADCCFFA6;">Вложенные функции имеют доступ к переменным объемлющей функции благодаря лексической области видимости. Это означает, что они могут "видеть" переменные, определенные в родительской функции.</mark>
- Да это так, называется - **Enclosing** (области внешних функций, если есть вложенность).
**Лексическая (статическая) область видимости** — это способ определения видимости переменных на основе их расположения в исходном коде (т.е. там, где они объявлены). Это означает, что доступ к переменным определяется структурой кода (вложенностью функций и модулей), а не порядком вызовов функций во время выполнения. [^5]

### 4.4.2	Виды областей видимости в Python
#### 4.4.2.1	Правило LEGB

![[Pasted image 20250301165828.png|600]]


**Локальные переменные**
**Локальная переменная** - это 

**Нелокальные переменные**
**Нелокальные переменные** — это переменные из **ближайшей внешней (объемлющей) функции**, но не глобальной области.
«Если нужно присвоить имя, находящееся в объемлющем операторе def, то начиная с Python З.Х, имя можно объявить как нелокальное в операторе **nonlocal**» ([Лутц, p. 506](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=507&annotation=RNBNRUG5))

**Глобальная область видимости**
«Включающий модуль является глобальной областью видимости» ([Лутц, p. 506](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=507&annotation=ZM6TXVEX)) 
«Вообще говоря, в Python нет понятия единственной всеобъемлющей глобальной области видимости, основанной на файлах» ([Лутц, p. 506](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=507&annotation=29PFJLUL)) хм, а в C++?

Можно явно задать с помощью оператора `global`
В C++ ситуация отличается от Python. Здесь **существует единая глобальная область видимости**, которая не ограничивается отдельными файлами.



## 4.5	Встроенные типы данных
«Неизменяемые типы (числа, строки, кортежи, фиксированные множества)» ([Лутц, p. 265](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=266&annotation=ZXCECJRW))
«Изменяемые типы (списки, словари, множества, байтовые массивы)» ([Лутц, p. 266](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=267&annotation=748M9IP8))
**Краткое обозначение типов в python

| Стандартные типы | Обозначения        |
| ---------------- | ------------------ |
| строковые        | **str<br>bytes**   |
| Числовые         | **int<br>integer** |
|                  |                    |


### 4.5.1	Числовые типы
### 4.5.2	Строковые типы
#### 4.5.2.1	string(str)
Неизменяемый тип
- Методы
endswith()

«Таблица 7.1. Распространенные строковые литералы и операции» ([Лутц, p. 221](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=222&annotation=T43AH4DN))


Для проверки типов можно использовать очень многое, например:
### 4.5.3	Когда что использовать?

| Метод              | Когда применять                                           |
| ------------------ | --------------------------------------------------------- |
| `type()`           | Если нужна точная проверка типа (без учета наследования). |
| `isinstance`       | Для проверки типа с учетом иерархии классов.              |
| Утиная типизация   | Когда важна функциональность, а не конкретный тип.        |
| `Protocol`/`match` | Для сложных структур данных или современных проектов.     |
| Аннотации типов    | Для статической проверки кода и документирования.         |
### 4.5.4	Прямая проверка типа через type()\
```python
if type(msg) is dict:
    print("Это именно словарь (не подкласс!)")
```
Не подходит, если объект может быть экземпляром подкласса `dict`.
- **Пример**:
```python
    class MyDict(dict): pass
    d = MyDict()
    print(type(d) is dict)    # False
    print(isinstance(d, dict)) # True
```
### 4.5.5	Утиная типизация(обработка исключений)
что это?
```python
if hasattr(msg, 'get') and 'op' in msg and 'a' in msg and 'b' in msg:
    # Работаем как со словарем
    operation = msg['op']
```
### 4.5.6	Используйте статическую проверку типов через аннотации (например, с mypy)


## 4.6	Коллекции(Контейнеры) 
У Mark Lutz типы данных не делятся на категории. Почему в Python не делят контейнеры на категории:
Операции над последовательностями не работают.
### 4.6.1	**Философия Python: простота и практичность**[^6]
- Python ориентирован на удобство и интуитивность. Типы данных в нём часто многофункциональны и не вписываются в жёсткие категории. Например:
    - **Списки** (list) могут использоваться как динамические массивы, стеки или очереди (хотя для очередей эффективнее `collections.deque`).
    - **Словари** (dict) реализуют ассоциативные массивы, но также поддерживают итерирование, что делает их гибкими.
- Жёсткая классификация, как в C++, могла бы ограничить восприятие возможностей структур данных в Python.

### 4.6.2	Последовательные контейнеры
**Важно:** Любой объект, реализующий методы `__getitem__` и `__len__`, может рассматриваться как последовательность.

Общие методы для них:
- pop()

#### 4.6.2.1	Списки
**`list`**
«Списки представляют собой позиционно упорядоченные коллекции объектов произвольных типов и не имеют фиксированных размеров» ([Лутц, p. 141](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=142&annotation=EKJ2DFIV))
  - **Описание**: Изменяемая последовательность элементов, поддерживающая произвольный доступ по индексу.
  - **Примеры использования**: 
    ```python
    fruits = ['apple', 'banana', 'cherry']
    ```




**`
`tuple`:
  - **Описание**: Неизменяемая последовательность элементов.
  - **Примеры использования**:
    ```python
    point = (1, 2, 3)
    ```

**`str`**:
  - **Описание**: Неизменяемая последовательность символов.
  - **Примеры использования**:
    ```python
    greeting = "Hello, world!"
    ```

**`deque` (из модуля `collections`)**:
  - **Описание**: Двусторонняя очередь, поддерживающая быстрые вставки и удаления элементов с обоих концов.
  - **Примеры использования**:
    ```python
    from collections import deque
    queue = deque(['Eric', 'John', 'Michael'])
    ```

### 4.6.3	Непоследовательные контейнеры (Unordered containers)
**`set`**:
  - **Описание**: Неупорядоченная коллекция уникальных элементов.
  - **Примеры использования**:
    ```python
    fruits = {'apple', 'banana', 'cherry'}
    ```

 **`frozenset`**:
  - **Описание**: Неупорядоченная коллекция уникальных элементов, которая неизменяема (аналог `set`, но неизменяемый).
  - **Примеры использования**:
    ```python
    frozen_fruits = frozenset(['apple', 'banana', 'cherry'])
    ```

### 4.6.4	Ассоциативные контейнеры (Associative containers)
#### 4.6.4.1	Словари[^7]
Изменяемый тип данных.
«Внутренне словари реализованы как хештаблицы [^8] (структуры данных, обеспечивающие очень быстрое извлечение), которые сначала имеют небольшие размеры и увеличиваются по требованию.» ([Лутц, p. 280](zotero://select/library/items/HZJ8WMF3)) ([pdf](zotero://open-pdf/library/items/IDSQ7HB8?page=281&annotation=WT9B4AKN))

`dict`
  - **Описание**: Коллекция пар "ключ-значение", где ключи уникальны.
  - Словарь можно объявить как и просто обозначив его в { }, так и явно dict()
```python
    student = {'name': 'John', 'age': 25}
	teacher = dict(name='Bryan', age=32)
	D = diet([(’name’, ’Bob’), (’age’, 40)]) 
	D = diet(zip(keyslist, valueslist)) 
	D = diet.fromkeys([’name’,’age’])
```
Словари реализуют протокол **отображений** (mapping)[^9]
Интересный факт, ключи можно делать разных типов, будто ключи это tupple.

Ошибка **"a variable annotation cannot be combined with tuple unpacking"** возникает в Python, когда вы пытаетесь объединить **аннотацию типов** переменных с **распаковкой кортежа** (tuple unpacking). Это происходит из-за ограничений синтаксиса аннотаций в Python.

***Как работает оператор : в Python.***
- аннотации `x:int`


Доступ к ним осуществляется:
```python
D['number']
D.get('number', default?) # Второй метод, D.get('number'), более безопасен.Он возвращает значение, если ключ есть в словаре, иначе возвращает None по умолчанию. 
```
Аргумент `default` позволяет избежать ошибок при работе с ключами, которые могут отсутствовать в словаре. Это удобно, когда вы не уверены в наличии ключа, но хотите обработать ситуацию безопасно. Возвращает значение default если значение отсутствует.

Можно посмотреть отдельно все ключи и все значения.
```python
D.viewkeys()
D.viewvalues()
```



### 4.6.5	Специализированные контейнеры (Specialized containers)
`defaultdict` (из модуля `collections`)**:
  - **Описание**: Словарь, который предоставляет значение по умолчанию для отсутствующих ключей.
  - **Примеры использования**:
    ```python
    from collections import defaultdict
    dd = defaultdict(int)
    ```

- **`OrderedDict` (из модуля `collections`)**:
  - **Описание**: Словарь, который помнит порядок добавления ключей.
  - **Примеры использования**:
    ```python
    from collections import OrderedDict
    od = OrderedDict()
    od['one'] = 1
    od['two'] = 2
    ```

- **`Counter` (из модуля `collections`)**:
  - **Описание**: Словарь для подсчета хэширующихся объектов. Элементы сохраняются как ключи словаря, а их количество — как значения.
  - **Примеры использования**:
    ```python
    from collections import Counter
    cnt = Counter(['apple', 'banana', 'apple', 'cherry'])
    ```

- **`namedtuple` (из модуля `collections`)**:
  - **Описание**: Кортеж с полями, доступными по именам.
  - **Примеры использования**:
    ```python
    from collections import namedtuple
    Point = namedtuple('Point', ['x', 'y'])
    p = Point(1, 2)
    ```

### 4.6.6	Вывод

Как видите, контейнеры в Python можно категоризовать по аналогичным признакам, что позволяет легко понимать и выбирать нужный контейнер для конкретных задач. В Python также есть дополнительные специализированные контейнеры в модуле `collections`, которые предоставляют улучшенные или специализированные возможности по сравнению с основными типами.

Для более подробной информации и примеров использования, можно обратиться к [официальной документации по модулям Python](https://docs.python.org/3/library/collections.html).


## 4.7	Виртуальные окружения(venv)
python -m venv .venv

### 4.7.1	Перенос папки с окружением
Перенос папки с проектом вместе с виртуальным окружением (venv) обычно вызывает проблемы потому, что в конфигурационных файлах окружения (таких как pyvenv.cfg) и в скриптах активации (activate, activate.bat, и т.п.) «зашиты» абсолютные пути к Python. В отличие от некоторых других менеджеров среды (например, conda), стандартные venv в Python не рассчитаны на «прозрачный» переезд в другое место.

Ниже несколько способов, как упростить жизнь при переносе:

3) Хранить виртуальное окружение отдельно от кода.  
   – Например, в Windows проект можно хранить в папке D:\Projects\my_project, а venv — в D:\Envs\my_project_venv.  
   – Тогда вы можете свободнее перемещать папку с самим проектом, пока не трогаете папку среды. При разворачивании на другом компьютере всё равно придётся создавать новое окружение, но на локальной машине это решит проблему «сломанных путей».

4) Документация «pip freeze + requirements.txt».  
   – Вместо переноса среды вы можете быстро заново «собрать» окружение:  
       pip freeze > requirements.txt  
     А затем, уже на новом месте или новой машине:  
       python -m venv .venv  
       .venv\Scripts\activate  
       pip install -r requirements.txt  
   – Все необходимые пакеты подтянутся, и у вас будет «чистое» окружение.

5) Использовать инструменты вроде Pipenv или Poetry.  
   – Вместо «чистого» venv можно применять [Pipenv](https://github.com/pypa/pipenv) или [Poetry](https://python-poetry.org/).  
   – Они более гибко управляют зависимостями и окружениями, что упрощает перенос проектов (всё описывается в Pipfile/Pipfile.lock или pyproject.toml/poetry.lock).

6) Просто пересоздавать окружение.  
   – Самое надёжное решение — заново создать виртуальное окружение на новом месте.  
   – При этом переносится только код и файлы зависимостей (requirements.txt или pyproject.toml).  

Таким образом, «прозрачно» перенести venv, просто переехав папкой, обычно не получается без ручного редактирования файлов. Поэтому чаще всего при любом «переезде» окружение (venv) либо создают заново, либо изначально хранят в другом месте, а в проекте держат лишь файл зависимостей. 

## 4.8	Оснащения

## 4.9	ООП в Python[^2]
«ООП предлагает отличающийся и часто более эффективный способ программирования, который предусматривает разложение кода на составляющие с целью минимизации избыточности и написания новых программ путем настройки существующего кода, а не его изменения на месте» ([Лутц, p. 20](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=21&annotation=FBK4TXC8))

«Тем не менее, по мере углубления в классы имейте в виду, что модель ООП в Python очень проста; как будет показано, в действительности она сводится все го лишь к поиску атрибутов в деревьях объектов и особому аргументу функций.» ([Лутц, p. 32](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=33&annotation=WT7KRAF7))

У марка лутца описан механизм доступа к атрибутам. Нужно узнать низкоуровневую систему. Дерево классов, в нем описываются 
	Поиск в дереве классов осуществляется слева на право что интересно, если два класса имеют одинаковый аргумент то берётся левый.


**Классы делятся на:**
- **Суперклассы**(в других книгах можно встретить **базовые классы**)
- **Подклассы**(**производные классы**)
	Они могут переопределять поведение определенное другими классами.
	

### 4.9.1	Методы в классе
Первый аргумент всегда `self`.

### 4.9.2	Объекты и экземпляры
Выделяется ли память для классов и для их объектов, почему лутц не пишет про модель объектов.

Атрибуты класса
«Функции внутри класса, как правило, называются методами» ([Лутц, p. 36](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=37&annotation=4D2ELKER))

Для создания экземпляра нужно указать что он является методом(без объявления типа, из за динамической типизации):
```python
bob = Engineer():
```


«Объекты классов происходят из операторов, а экземпляры — из вызовов» ([Лутц, p. 34](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=35&annotation=S5MG95JS))

Функция `isinstance()` в Python — встроенная функция для **проверки типа объекта**. Она отвечает на вопрос: _"Является ли этот объект экземпляром указанного класса (или его подкласса)?"_
```python
isinstance(msg, dict)
```
### 4.9.3	Параметр self 
Возможно он необходим из за особенности объектной модели или дерева поиска в Python. Да! Как я понял из за поиска в дереве, передается особый первый аргумент - self, указатель на конкретный экземпляр.

Как мы также узнаем, методы можно вызывать либо через экземпляр (bob. giveRaise ()), либо че рез класс`(Employee.giveRaise (bob))

Что было бы, если бы не было self
### 4.9.4	Конструктор(метод инициализации)
Есть настоящий конструктор - `def __new__()`, но используют чаще
Выглядит как 
```python
def __init__(self):
```

##### 4.9.4.1.1	Python super() Function
Create a class that will inherit all the methods and properties from another class
`super`(_type_[, _object-or-type_])[](https://docs.python.org/2/library/functions.html#super "Permalink to this definition")
Return a ***proxy?*** object that delegates method calls to a parent or sibling class of _type_. This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by [`getattr()`](https://docs.python.org/2/library/functions.html#getattr "getattr") except that the _type_ itself is skipped.
### 4.9.5	Композиция
«Как только вы привыкнете к программированию в таком стиле (путем **настройки программного обеспечения**), вы обнаружите, что когда наступает время написания новой программы, большая часть работы может оказаться сделанной — в значительной степени ваша задача сводится к смешиванию существующих **суперклассов**, которые уже реализуют поведение, требующееся для программы.» ([Лутц, p. 31](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=32&annotation=JZTTEQT9))

### 4.9.6	Иерархия наследования
Множественное наследование
Сверху вниз, слева на право

Классы автоматически связываются со своими суперклассами в соответствии со способом их перечисления внутри круглых скобок в строке заголовка class; по рядок слева направо здесь дает порядок в дереве. Хотя всегда можно задать явно откуда взять аргумент. C3.z например, а не C1.
```python
	class Engineer(Employee):
		def computeSalary(self):
			pass
```
При переопределении метода он **переопределит** универсальный, если он есть, и в дереве классов он первее. ([Лутц, p. 30](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=31&annotation=WKRDGYZ9))

### 4.9.7	Полиморфиз
Смысл объекта(то есть действия) зависят от типа объекта, и в зависимости от типа выбирается(***ВЫНЕСТИ ЭТО В ЗАМЕТКУ ПО ООП, НУЖНО РАЗДЕЛЯТЬ СМЫСЛЫ***).
### 4.9.8	Инкапсуляция
В других приложениях полиморфизм также может использоваться для сокрытия (т.е. инкапсуляции} отличий в интерфейсах

### 4.9.9	Проектирование классов на Python
«С этой целью программисты начали каталогизировать рас пространенные структуры ООП, известные как паттерны проектирования, которые призваны помочь в решении проблем, возникающих при проектировании.» ([Лутц, p. 32](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=33&annotation=NQIVS2ZG))

### 4.9.10	Абстрактные классы


# 5	Модули
- import модулей:
Также import можно вкладывать в любые блоки.


## 5.1	os и subproccess
1. **`os`** — предоставляет функции для работы с операционной системой (файловая система, переменные окружения и т.д.).
    
2. **`subprocess`** — позволяет запускать внешние программы и взаимодействовать с ними (например, открывать файлы в Adobe Acrobat).

## 5.2	Документация в Python
docstrings
О том, какие существуют соглашения в документировании Python кода описано в документации [PEP257](https://www.python.org/dev/peps/pep-0257/).
Пример:
```python
 """Класс TextSplitter используется для разбивки текста на слова

    Основное применение - парсинг логов на отдельные элементы
    по указанному разделителю.

    Note:
        Возможны проблемы с кодировкой в Windows
    
    Attributes
    ----------
    file_path : str
        полный путь до текстового файла
    lines : list
        список строк исходного файла

    Methods
    -------
    load()
        Читает файл и сохраняет его в виде списка строк в lines
    get_splitted(split_symbol=" ")
        Разделяет строки списка по указанному разделителю
        и возвращает результат в виде списка
    """
```
### 5.2.1	Документация для пакетов[](https://pythonchik.ru/osnovy/dokumentirovanie-koda-v-python#dokumentaciya-dlya-paketov)

Документация пакета размещается в файле `__init__.py` в верхней части файла (начиная с 1-й строки). В ней может быть указано:

- описание пакета;
- список модулей и пакетов, экспортируемых этим модулем;
- автор;
- контактные данные;
- лицензия.

```python
"""
Пакет Mos помогает создать полноэкранный текстовый интерфейс в консоли.

Alex Ivanov [https://alex.ivanov.ru/]
alex.ivanov@gmail.com
# License: BSD
"""
__author__ = 'Alex Ivanov'

try:
    from .version import version
except ImportError:
    version = "0.0.0"

__version__ = version
```
### 5.2.2	Pydoc
Pydoc[](https://pythonchik.ru/osnovy/dokumentirovanie-koda-v-python#pydoc)
https://pythonchik.ru/osnovy/dokumentirovanie-koda-v-python

Для более удобной работы с документацией, в Python существует встроенная библиотека pydoc.

Pydoc автоматически генерирует документацию из Python модулей. Информацию по доступным командам модуля `pydoc` можно получить набрав в терминале:
### 5.2.3	sphinx
https://habr.com/ru/companies/netologyru/articles/815563/

## 5.3	Тестирование
Есть unittest и pytest
Выбор между `unittest` и `pytest` зависит от ваших потребностей и стиля написания тестов. Оба инструмента решают одни задачи, но делают это по-разному. Вот их ключевые различия и сценарии применения:
- **`unittest`** — ВСТРОЕН В PYTHON. Если вы работаете в среде, где нельзя устанавливать сторонние пакеты, или нужно поддерживать легаси-код.
    
- **`pytest`** — для новых проектов: он сокращает объем кода, упрощает параметризацию и дает больше возможностей.

Всё [[pycharm |тестирование можно осуществлять в pycharm]], это довольно удобно.
### 5.3.1	unittest

### 5.3.2	pytest


## 5.4	matplotlib
Позволяет делать анимации функций и т.д.
![[Pasted image 20250208211504.png]]
## 5.5	numpy
https://numpy.org/doc/2.2/index.html

## 5.6	pandas
- Какой deepseek классный:
Название **Pandas** — это **каламбур**:  
✅ **Pan**el Data + **Python** **Da**ta **S**cience → **Pandas**.  
✅ Панда-животное — символ, а не источник названия (но очень милый бонус 😊).
### 5.6.1	Basic data structures in pandas[](https://pandas.pydata.org/docs/user_guide/10min.html#basic-data-structures-in-pandas "Link to this heading")

Pandas provides two types of classes for handling data:
1. [`Series`](https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series "pandas.Series"): a one-dimensional labeled array holding data of any type
    such as integers, strings, Python objects etc.
2. [`DataFrame`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"): a two-dimensional data structure that holds data like a two-dimension array or a table with rows and columns.

## 5.7	pickle
«Список company в приведенном примере мог бы быть базой данных в случае хранения в файле посредством модуля pickle, представленного в главе 9, чтобы обеспечить постоянство для объектов сотрудников.» ([Лутц, p. 31](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=32&annotation=DIFMPXBM))

## 5.8	shelve
«Python также поставляется с модулем по имени shelve, который позволяет сохранять обработанные с помощью pickle представления экземпляров классов в файло вой системе с доступом по ключу; мы рассмотрим эту тему в главе 28.» ([Лутц, p. 31](zotero://select/library/items/77XQPJZM)) ([pdf](zotero://open-pdf/library/items/EH6PG8HD?page=32&annotation=W76D9B65))
## 5.9	Enum
https://docs.python.org/3/library/enum.html
Её можно отнести к [[00 Python#4.5 Встроенные типы данных]] чуть чуть.
Концепция перечислений в Python (`enum`) **вдохновлена C++**, но реализована более мощно и гибко благодаря динамической природе Python. Если в C++ перечисления — это в первую очередь целые числа с именами, то в Python это полноценные объекты с богатой функциональностью.
### 5.9.1	Полезные функции и декораторы
1. @unique
Гарантирует, что все значения в перечислении уникальны
## 5.10	Logging
This module defines functions and classes which implement a flexible event logging system for applications and libraries.

The key benefit of having the logging API provided by a standard library module is that all Python modules can participate in logging, so your application log can include your own messages integrated with messages from third-party modules.

Here’s a simple example of idiomatic usage:
## 5.11	dataclasses


# 6	Компиляция Python и его вариации(pyiron, cpython, jython)

## 6.1	Компиляция






links::





[^1]: Изучить бы как работают интепретируемые и комплияторные языки

[^2]: Почему лутц сравнивает классы с модулями? Чтобы было удобно объяснить читателю?

[^3]: *Переделать определение более точно, и возможно вынести его в другую заметку.*

[^4]: Изучить как в python это устроено на низком уровне. 
	Например как области видимости связываются с функциями.

[^5]: Хм, что значит порядок вызов функций, как на основе этого определить область видимости?

[^6]: ***Надо бы PEP по этому найти***

[^7]: ***Почему они так называны?***

[^8]: ***Хм, а хеш таблицы могут ли быть *** 

[^9]: Как это?

[^10]: 

[^11]: Вынести в отдельную заметку о теории языков программирования
